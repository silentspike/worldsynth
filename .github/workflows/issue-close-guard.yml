name: Issue Close Guard

on:
  issues:
    types: [closed]

permissions:
  issues: write

jobs:
  verify-closure:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labels = issue.labels.map(l => l.name);

            // Nur type:feature und type:bug pruefen
            const isTrackable = labels.some(l =>
              l === 'type:feature' || l === 'type:bug'
            );
            if (!isTrackable) return;

            // --- Check 1: status:verified Label ---
            const hasVerified = labels.includes('status:verified');

            // --- Check 2: Inkompatibler Status ---
            const wrongStatus = labels.filter(l =>
              l === 'status:blocked' ||
              l === 'status:ready' ||
              l === 'status:in-progress'
            );

            // --- Check 3: Verify-Report Kommentar ---
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number
            });

            const verifyComments = comments.data.filter(c =>
              /## Verify-Report/i.test(c.body)
            );
            const hasReport = verifyComments.length > 0;

            // --- Check 4: AC-IDs aus Body muessen im Report stehen ---
            const bodyAcIds = [...body.matchAll(/AC-(\d+)/g)].map(m => m[0]);
            const uniqueAcIds = [...new Set(bodyAcIds)];

            let missingAcs = [];
            if (hasReport && uniqueAcIds.length > 0) {
              const reportBody = verifyComments.map(c => c.body).join('\n');
              missingAcs = uniqueAcIds.filter(ac => !reportBody.includes(ac));
            }

            // --- Check 5: Commands im Report (nicht nur Text) ---
            const hasCommands = verifyComments.some(c =>
              /`[^`]{3,}`/.test(c.body) &&
              /Command:|command:|Verify:|pass|fail/i.test(c.body)
            );

            // --- Check 6: scope:full braucht Deploy Evidence ---
            const isScopeFull = labels.includes('scope:full');
            const hasDeployEvidence = verifyComments.some(c =>
              /ssh |systemctl |curl.*health|docker |deploy|System\/Artifact/i.test(c.body)
            );

            // Failures sammeln
            const failures = [];
            if (!hasVerified) {
              failures.push('Missing `status:verified` label');
            }
            if (wrongStatus.length > 0) {
              failures.push(`Incompatible status labels: ${wrongStatus.join(', ')}`);
            }
            if (!hasReport) {
              failures.push('No `## Verify-Report` comment found');
            }
            if (missingAcs.length > 0) {
              failures.push(`ACs missing in Verify-Report: ${missingAcs.join(', ')}`);
            }
            if (hasReport && !hasCommands) {
              failures.push('Verify-Report has no concrete commands/evidence');
            }
            if (isScopeFull && !hasDeployEvidence) {
              failures.push('scope:full requires deploy/system evidence in Verify-Report');
            }

            if (failures.length > 0) {
              // REOPEN
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'open'
              });

              // Falsche Labels entfernen
              for (const label of ['status:completed', 'status:verified']) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                } catch {}
              }

              // needs-evidence setzen
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['quality:needs-evidence']
                });
              } catch {}

              // Kommentar mit Anleitung
              const acList = uniqueAcIds.length > 0
                ? `\n\n**Erwartete ACs im Report:** ${uniqueAcIds.join(', ')}`
                : '';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: [
                  '## Issue Automatisch Reopened',
                  '',
                  'Dieses Issue wurde ohne ausreichende Verifikation geschlossen.',
                  '',
                  '**Fehlende Anforderungen:**',
                  ...failures.map(f => `- ${f}`),
                  acList,
                  '',
                  '**Um dieses Issue korrekt zu schliessen:**',
                  '1. Poste einen `## Verify-Report` Kommentar (Template unten)',
                  '2. Der Report muss ALLE AC-IDs aus dem Issue-Body enthalten',
                  '3. Der Report muss konkrete Commands mit Output enthalten',
                  '4. Setze das Label `status:verified`',
                  '5. Schliesse das Issue erneut',
                  '',
                  '```markdown',
                  '## Verify-Report',
                  '| AC-ID | Ergebnis | Command | Output | Artefakt |',
                  '|-------|----------|---------|--------|----------|',
                  '| AC-1  | pass/fail | `<konkreter befehl>` | <output> | <pfad> |',
                  '',
                  '**NOT Tested:** [was + warum]',
                  '**Confidence:** [0-100% + 1 Satz]',
                  '```'
                ].join('\n')
              });

              core.setFailed(`Issue #${issue.number} reopened: missing verification evidence`);
            }
