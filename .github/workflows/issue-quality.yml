name: Issue Quality Gate

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled]

permissions:
  issues: write

jobs:
  quality-gate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = (issue.body || "");
            const labels = (issue.labels || []).map(l => l.name);

            // Skip epic issues (they have different structure)
            if (labels.includes("type:epic")) return;

            // Accept both German and English section headers, plus WP-Brief format
            const requiredChecks = [
              {
                name: "In Scope / Files",
                found: body.includes("## In Scope") || body.includes("## Files")
              },
              {
                name: "Acceptance Criteria",
                found: body.includes("## Akzeptanzkriterien") || body.includes("## Acceptance Criteria")
              },
            ];
            const sectionMissing = requiredChecks.filter(s => !s.found).map(s => s.name);

            const hasAcId = /AC-\d+/m.test(body);
            const hasVerify = /Verify|Verify-Methode|## Verify/i.test(body);

            const hasType = labels.some(l => l.startsWith("type:"));
            const hasSize = labels.some(l => l.startsWith("size:"));
            const hasScope = labels.some(l => l.startsWith("scope:"));
            const hasSprint = labels.some(l => l.startsWith("sprint:"));

            const failures = [];
            if (sectionMissing.length) failures.push("Missing sections: " + sectionMissing.join(", "));
            if (!hasAcId) failures.push("Missing AC-ID (AC-1, AC-2, ...)");
            if (!hasVerify) failures.push("Missing Verify method");
            if (!hasType) failures.push("Missing type:* label");
            if (!hasSize) failures.push("Missing size:* label");
            if (!hasScope) failures.push("Missing scope:* label");
            if (!hasSprint) failures.push("Missing sprint:* label");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = issue.number;

            if (failures.length > 0) {
              // Add quality:needs-spec if not present
              if (!labels.includes("quality:needs-spec")) {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number,
                  labels: ["quality:needs-spec"]
                });
              }
              // Remove quality:ready if present
              if (labels.includes("quality:ready")) {
                await github.rest.issues.removeLabel({
                  owner, repo, issue_number,
                  name: "quality:ready"
                }).catch(() => {});
              }

              // Only comment on newly opened issues to avoid spam
              if (context.payload.action === "opened") {
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: "### Issue Quality Gate: Needs Spec\n\n" +
                        failures.map(f => `- ${f}`).join("\n") +
                        "\n\nSetze das Issue erst auf `status:ready`, wenn alle Punkte erfuellt sind."
                });
              }
            } else {
              // Add quality:ready if not present
              if (!labels.includes("quality:ready")) {
                await github.rest.issues.addLabels({
                  owner, repo, issue_number,
                  labels: ["quality:ready"]
                });
              }
              // Remove quality:needs-spec if present
              if (labels.includes("quality:needs-spec")) {
                await github.rest.issues.removeLabel({
                  owner, repo, issue_number,
                  name: "quality:needs-spec"
                }).catch(() => {});
              }
            }
